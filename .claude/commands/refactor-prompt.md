# Prompt Refactoring to Skills Architecture

**사용법**: `/refactor-prompt <파일경로>`

**예시**: `/refactor-prompt .cursor/rules/testing-strategy.mdc`

---

당신은 '프롬프트 아키텍트(Prompt Architect)'입니다.

입력된 파일 경로에 있는 기존의 복잡한 프롬프트(Monolithic Prompt)를 읽어들인 후, 이를 Claude의 'Skills' 아키텍처에 맞게 모듈화된 유닛으로 리팩터링(Refactoring)하는 작업을 수행합니다.

---

## 🔍 0단계: 사전 준비 및 맥락 파악

### 0.1 입력 프롬프트 분석
1. **입력 프롬프트 읽기**: 지정된 파일을 Read 도구로 읽어들입니다.
2. **프롬프트 특성 파악**:
   - 프롬프트의 주요 목적과 도메인 파악
   - 복잡도 수준 판단 (단순/중간/복합)
   - 필요한 리소스 유형 예측 (정적 지식/실행 도구/둘 다/없음)

### 0.2 기존 스킬 탐색 (중복 방지)
**중요**: 새 스킬 생성 전에 **반드시** 기존 스킬을 확인합니다.

1. **기존 스킬 디렉토리 스캔**:
   ```bash
   # Glob으로 .claude/skills/ 내 모든 SKILL.md 파일 찾기
   ```

2. **각 기존 스킬 분석**:
   - SKILL.md를 읽어 스킬의 역할과 책임 파악
   - 현재 프롬프트와의 기능적 중복도 판단

3. **재사용 가능성 평가**:

   | 중복도 | 판단 기준 | 액션 |
   |--------|-----------|------|
   | **완전 일치** (90%+) | 동일한 역할과 책임 | ✅ 기존 스킬 그대로 사용 |
   | **높은 유사** (70-90%) | 핵심 기능 동일, 세부사항 다름 | 🔧 기존 스킬 안전 확장 |
   | **부분 중복** (40-70%) | 일부 기능만 겹침 | 🤔 케이스별 판단 (분리 or 통합) |
   | **낮은 유사** (<40%) | 다른 도메인/목적 | ➕ 새 스킬 생성 |

4. **스킬 확장 전략** (높은 유사도 시):
   - **지식 확장**: knowledge/ 폴더에 새 도메인 파일 추가
   - **도구 확장**: tools/ 폴더에 새 스크립트 추가
   - **SKILL.md 확장**: "또한 [새 기능]도 수행합니다" 섹션 추가
   - **하위 스킬 생성**: 기존 스킬을 추상화하고 구체적 하위 스킬 생성

### 0.3 Skills Cookbook 참조 (선택적)
- 유사한 스킬 패턴이 있는지 WebFetch로 https://github.com/anthropics/anthropic-skills-cookbook 탐색
- 참조할 만한 베스트 프랙티스가 있다면 활용

---

## 🌳 1단계: 프롬프트 분석 및 분해 (ToT Deconstruction)

**도구**: Sequential MCP를 사용하여 구조화된 사고 과정을 진행합니다.

### 1.1 후보 생성 (Candidate Generation)
- 프롬프트 복잡도에 따라 **동적으로 후보 개수 결정**:
  - 단순 프롬프트 (100줄 미만): 2-3개 조합
  - 중간 프롬프트 (100-300줄): 3-5개 조합
  - 복합 프롬프트 (300줄 이상): 5-7개 조합
- 가능한 스킬 분해 조합을 나열 (예: [A, B, C], [A+B, C], [A, B+C])

### 1.2 평가 (Evaluation)
각 후보 조합을 다음 기준으로 평가하되, **프롬프트 특성에 따라 가중치를 동적 조정**:

| 평가 기준 | 설명 | 점수 범위 |
|-----------|------|-----------|
| **단일 책임 원칙** | 각 스킬이 하나의 명확한 책임만 가지는가? | 0-10 |
| **재사용성** | 다른 프롬프트/컨텍스트에서도 활용 가능한가? | 0-10 |
| **문맥적 효율성** | 스킬 간 협업 시 오버헤드가 적은가? | 0-10 |

**평가 표 예시**:
```
| 조합 | SRP | 재사용성 | 효율성 | 총점 | 비고 |
|------|-----|----------|--------|------|------|
| [A, B, C] | 9 | 8 | 6 | 23 | 재사용성 높으나 협업 복잡 |
| [A+B, C] | 7 | 6 | 9 | 22 | 효율적이나 SRP 약함 |
```

### 1.3 최종 선택 (Selection)
- **기본 원칙**: 총점이 가장 높은 조합 선택
- **동점 시**: 재사용성 > SRP > 효율성 순으로 우선순위 적용
- **예외 허용**: 프롬프트 특성상 특정 기준이 더 중요하다면 근거와 함께 다른 조합 선택 가능

## 🏗️ 2단계: 스킬 정의 및 구현 (Implementation)

### 2.1 스킬 구조 결정 (동적 판단)

**각 스킬**에 대해 다음 체크리스트로 필요한 컴포넌트를 판단:

#### 체크리스트: knowledge/ 폴더 필요성
다음 중 하나라도 해당하면 `knowledge/` 폴더 생성:
- [ ] 정적 규칙/가이드라인 참조 (코딩 컨벤션, API 명세 등)
- [ ] 예제 데이터/템플릿 필요
- [ ] 도메인 특화 지식 문서 필요
- [ ] 체크리스트, 설정 파일 등 참조 자료 필요

#### 체크리스트: tools/ 폴더 필요성
다음 중 하나라도 해당하면 `tools/` 폴더 생성:
- [ ] 코드 실행/검증 스크립트 필요 (린터, 테스터 등)
- [ ] 파일 조작/분석 도구 필요
- [ ] 외부 API 호출 스크립트 필요
- [ ] 데이터 변환/처리 로직 필요

### 2.2 기본 스킬 구조 템플릿

```
/skill_name
├── SKILL.md              # (필수) 스킬의 핵심 지침
├── knowledge/            # (조건부) 위 체크리스트 기준 판단
│   └── [관련 파일들]
└── tools/                # (조건부) 위 체크리스트 기준 판단
    └── [스크립트 파일들]
```

### 2.3 SKILL.md 작성 가이드

**필수 포함 요소** (프롬프트 특성에 맞게 조정):
1. **역할 정의**: "당신은 [명확한 역할]입니다"
2. **핵심 책임**: 이 스킬이 담당하는 구체적인 작업
3. **작동 방식**:
   - knowledge/ 참조 방법 (있는 경우)
   - tools/ 실행 방법 (있는 경우)
4. **제약 조건**: 하지 말아야 할 것, 주의사항
5. **출력 형식**: 사용자에게 제공할 결과 포맷

**유연성**: 단순한 스킬은 간결하게, 복잡한 스킬은 상세하게 작성

### 2.4 리소스 파일 생성 (필요시)

**knowledge/ 파일 예시** (실제 필요성 판단 후 작성):
- 정적 규칙이 명확히 있는 경우에만 구체적으로 작성
- 그렇지 않으면 구조만 제안하고 "[프롬프트 내용을 기반으로 추출]" 표시

**tools/ 스크립트 예시** (실제 필요성 판단 후 작성):
- 명확한 실행 로직이 있는 경우에만 구체적 코드 작성
- 그렇지 않으면 의사코드(pseudocode) 또는 "[구현 필요]" 표시

## ⚡ 3단계: 커맨드 재정의 (Command Refactoring)

### 3.1 새로운 커맨드 제안 (동적 개수)
- **기본**: 1-2개의 커맨드 제안
- **복합 프롬프트**: 사용 시나리오가 다양하면 3개까지 제안 가능
- **단순 프롬프트**: 단일 커맨드만 제안 가능

### 3.2 커맨드 설계 원칙
1. **간결성**: 기존 프롬프트보다 짧고 직관적
2. **명확성**: 사용 목적이 명확히 드러남
3. **파라미터 최소화**: 필수 파라미터만 포함, 선택적 파라미터는 필요시만

### 3.3 기능 커버리지 검증
새 커맨드가 기존 프롬프트의 **핵심 기능을 모두 커버**하는지 확인:
- [ ] 주요 기능 1: [기존 기능] → [새 커맨드로 가능]
- [ ] 주요 기능 2: [기존 기능] → [새 커맨드로 가능]
- [ ] (필요시 추가)

누락된 기능이 있다면 커맨드 수정 또는 추가 커맨드 제안

---

## 📊 4단계: 분석 결과 및 실행 계획

### 4.1 ToT 의사결정 요약
**간결하게 핵심만 요약**:
- 고려한 주요 후보 조합 (2-3개만)
- 최종 선택 조합과 점수
- 선택 근거 (1-2문장)

### 4.2 예상 작동 시뮬레이션 (CoT)

**형식**:
```
사용자: [제안된 새 커맨드]
→ Claude 내부 사고:
  1. [스킬 A] 감지: [감지 이유]
  2. [스킬 B] 감지: [감지 이유]
  3. 스킬 조합 전략: [협업 방식]
→ Claude 응답: [최종 출력 예시]
```

**깊이 조절**: 프롬프트 복잡도에 따라 시뮬레이션 상세도 조정

### 4.3 참고 자료
- **Skills 소개**: https://www.claude.com/blog/skills
- **Skills Cookbook**: https://github.com/anthropics/anthropic-skills-cookbook
- **공식 문서**: https://docs.anthropic.com/claude/docs/agent-skills

---

## ✅ 5단계: 최종 산출 및 파일 생성

### 5.1 산출물 요약
다음 정보를 사용자에게 제공:
1. **스킬 재사용/확장/생성 전략**:
   - 재사용: [기존 스킬 이름] → 그대로 활용
   - 확장: [기존 스킬 이름] → [확장 내용]
   - 신규: [새 스킬 이름] → [책임, 필요 리소스]
2. **최종 스킬 조합** (재사용 + 확장 + 신규)
3. **스킬 폴더 구조** (파일 트리)
4. **새 커맨드 사용법** (예시 1-2개)
5. **ToT 의사결정 근거** (간결한 요약)
6. **CoT 작동 시뮬레이션** (1-2개 시나리오)

### 5.2 실제 파일 생성/수정
**생성 전 확인**: 사용자에게 작업 계획을 제시하고 확인 후 진행

#### A. 신규 스킬 생성
`.claude/skills/` 디렉토리에 다음을 생성:
- 각 스킬의 SKILL.md (필수)
- knowledge/ 파일 (필요시)
- tools/ 스크립트 (필요시)

#### B. 기존 스킬 확장 (안전하게)
확장이 필요한 기존 스킬에 대해:
1. **백업 생성**: 수정 전 기존 내용 백업
2. **안전 확장 원칙**:
   - 기존 기능 유지: 기존 역할과 책임 보존
   - 명확한 구분: "## 추가 기능: [새 도메인]" 섹션 추가
   - 하위 호환성: 기존 사용 패턴이 계속 작동하도록 보장
3. **확장 방법**:
   - SKILL.md 하단에 새 섹션 추가
   - knowledge/ 폴더에 새 도메인별 파일 추가
   - tools/ 폴더에 새 스크립트 추가 (기존 것과 충돌 없이)

#### C. 커맨드 파일 탐색 및 수정
1. **관련 커맨드 찾기**:
   ```bash
   # Glob으로 .claude/commands/*.md 파일 스캔
   # Grep으로 입력 프롬프트 파일명 검색
   ```

2. **커맨드 파일 수정 전략**:
   - 기존 프롬프트 내용을 스킬 호출로 대체
   - 형식: "다음 스킬을 사용하여 작업을 수행하세요: [스킬명1], [스킬명2]"
   - 원본 보존: 주석으로 기존 프롬프트 내용 보관 (롤백 대비)

3. **수정 예시**:
   ```markdown
   # Before
   긴 프롬프트 내용...

   # After
   이 작업을 수행하기 위해 다음 스킬을 사용합니다:
   - **[스킬명1]**: [역할 요약]
   - **[스킬명2]**: [역할 요약]

   <!-- 원본 프롬프트 (참고용):
   긴 프롬프트 내용...
   -->
   ```

---

## 🔄 6단계: 커맨드 파일 업데이트 (후속 작업)

### 6.1 관련 커맨드 자동 탐색
1. **파일명 기반 탐색**:
   - 입력 프롬프트 파일명에서 키워드 추출 (예: "testing-strategy" → "testing", "strategy")
   - `.claude/commands/` 내에서 해당 키워드 포함 파일 검색

2. **내용 기반 탐색**:
   - 입력 프롬프트의 핵심 키워드/도메인 추출
   - Grep으로 해당 키워드를 포함하는 커맨드 파일 찾기

### 6.2 커맨드 파일 리팩터링
**발견된 각 커맨드 파일**에 대해:

1. **영향도 분석**:
   - 커맨드가 변환된 프롬프트를 직접 참조하는가?
   - 간접적으로 관련되는가?

2. **수정 방법 결정**:

   | 영향도 | 수정 방법 |
   |--------|-----------|
   | **직접 참조** | 프롬프트 내용을 스킬 호출로 완전 대체 |
   | **간접 관련** | 관련 스킬 참조를 권장사항으로 추가 |
   | **무관** | 수정하지 않음 |

3. **실제 수정 수행**:
   ```markdown
   # 수정된 커맨드 파일 구조

   # [커맨드 제목]

   **사용법**: `/command-name [params]`

   ## 스킬 기반 실행

   이 커맨드는 다음 스킬을 조합하여 실행됩니다:

   1. **[스킬명1]** (`.claude/skills/skill1/`)
      - 역할: [간단한 설명]

   2. **[스킬명2]** (`.claude/skills/skill2/`)
      - 역할: [간단한 설명]

   ## 실행 절차

   [스킬 조합 방식 설명]

   <!--
   === 원본 프롬프트 (백업) ===
   [기존 프롬프트 전체 내용]
   ===========================
   -->
   ```

### 6.3 검증 및 롤백 계획
1. **변경 사항 요약 제공**:
   - 수정된 커맨드 파일 목록
   - 각 파일의 변경 내용 요약

2. **롤백 가이드 제공**:
   ```markdown
   # 롤백 방법
   각 파일의 <!-- 원본 프롬프트 --> 섹션을 복원하면 됩니다.
   ```

---

## 🎯 실행 지침

- **동적 판단 우선**: 프롬프트 특성을 먼저 파악하고, 그에 맞게 절차 조정
- **과도한 구조화 지양**: 단순한 프롬프트에 복잡한 구조 강요하지 않기
- **근거 제시**: 판단 시 "왜 이렇게 했는지" 간단히 설명
- **유연성 유지**: 정해진 틀에 얽매이지 않고 최적의 방법 선택
- **안전한 수정**: 기존 스킬 확장 시 하위 호환성 보장, 원본 내용 보존
- **자동화 우선**: 관련 커맨드 파일 자동 탐색 및 일괄 수정 제안

---

## ⚠️ 문제 해결 (Troubleshooting)

### 스킬 구조 누락
**문제**: `.claude/skills/` 디렉토리 구조가 없거나 불완전함

**Fallback 동작**:
1. ⚠️ 스킬 구조 누락 경고
2. 기본 스킬 템플릿 제공:
   - SKILL.md 기본 구조
   - knowledge/ 디렉토리 예시
   - tools/ 디렉토리 예시
3. 수동 리팩토링 가이드 제공

**해결 방법**:
```bash
# 스킬 템플릿 구조 확인
.claude/skills/example-skill/
├─ SKILL.md
├─ knowledge/
│  └─ example-knowledge.md
└─ tools/
   └─ example-tool.sh

# 기본 구조 생성
mkdir -p .claude/skills/new-skill/{knowledge,tools}
touch .claude/skills/new-skill/SKILL.md
```

### 프롬프트 파일 형식 오류
**문제**: 변환할 프롬프트 파일이 표준 형식이 아님

**Fallback 동작**:
1. ⚠️ 형식 오류 경고
2. 수동 구조 분석 시도
3. 부분적 변환 제공:
   - 읽을 수 있는 부분만 변환
   - 나머지는 원본 유지
   - 수동 수정 권장

**해결 방법**:
```bash
# 프롬프트 파일 형식 확인
# 필수 섹션:
# - 역할 (Role)
# - 책임 (Responsibilities)
# - 실행 방식 (How it works)

# 수동 정리 후 재시도
```

### 중복 스킬 발견
**문제**: 변환하려는 스킬이 이미 존재함

**Fallback 동작**:
1. ⚠️ 중복 스킬 경고
2. 옵션 제공:
   - 기존 스킬 덮어쓰기
   - 새 이름으로 생성 (_v2, _v3)
   - 취소
3. 사용자 선택 대기

**해결 방법**:
```bash
# 기존 스킬 확인
ls -la .claude/skills/

# 기존 스킬 백업
cp -r .claude/skills/existing-skill .claude/skills/existing-skill.backup

# 새 이름으로 생성
/refactor-prompt "prompt-name" --output "new-skill-name"
```

### Knowledge 추출 실패
**문제**: 프롬프트에서 knowledge 파일 분리 실패

**Fallback 동작**:
1. ⚠️ Knowledge 추출 실패 알림
2. SKILL.md에 모든 내용 포함
3. 수동 분리 권장:
   - 개념 정의 → knowledge/
   - 실행 로직 → SKILL.md
   - 스크립트 → tools/

**해결 방법**:
```bash
# 수동 분리 후 재구성
# 1. SKILL.md에서 개념 부분 식별
# 2. knowledge/*.md 파일로 이동
# 3. SKILL.md에서 참조 링크 추가
```

## 📖 사용 예시

### 기본 사용법
```
/refactor-prompt
```

### 실제 시나리오

#### 시나리오 1: .cursor/rules → Skills 마이그레이션
```
상황: 기존 .cursor/rules/testing-strategy.mdc를 Skill로 전환
명령: /refactor-prompt
대상: .cursor/rules/testing-strategy.mdc
결과:
  - .claude/skills/test-generator/ 생성
  - SKILL.md (메타데이터 + 실행 지침)
  - knowledge/testing-strategy.md (원본 내용)
  - tools/ (스크립트 분리)
  - README.md 자동 생성
```

#### 시나리오 2: 중복 스킬 방지
```
상황: 이미 존재하는 스킬 이름으로 변환 시도
명령: /refactor-prompt
대상: .cursor/rules/code-review.mdc
결과:
  ⚠️ code-quality-reviewer 스킬 이미 존재
  선택지:
  1. 덮어쓰기 (기존 삭제)
  2. 새 이름으로 생성 (code-review-v2)
  3. 병합 (기존 스킬에 내용 추가)
```

#### 시나리오 3: 복잡한 프롬프트 분해
```
상황: 거대한 create-plugin.mdc를 여러 스킬로 분리
명령: /refactor-prompt
결과:
  - ui-plugin-guidelines (호환성 분석)
  - react-plugin-implementation (구현 패턴)
  - dependency-management (의존성 관리)
  각 스킬이 독립적으로 동작 가능
```

## 💡 팁
- **점진적 마이그레이션**: 중요한 프롬프트부터 하나씩 변환
- **스킬 네이밍**: 동사-명사 형식 (예: analyze-structure, generate-test)
- **지식 보존**: 원본 .mdc 파일은 knowledge/로 백업
- **재사용성**: 여러 명령어에서 공유 가능한 스킬로 설계


---

## ✅ 성공 시 출력

```
✅ Prompt → Skill 변환 완료!

📊 변환 결과:
- 원본: .cursor/rules/testing-strategy.mdc
- 대상: .claude/skills/test-generator/
- 스킬 타입: 독립 실행형

📁 생성된 파일:
- .claude/skills/test-generator/
  ├─ SKILL.md (메타데이터 + 실행 지침)
  ├─ README.md (스킬 소개)
  ├─ knowledge/
  │  └─ testing-strategy.md (원본 내용 보존)
  └─ tools/
     ├─ test_generator.ts (스크립트 분리)
     └─ coverage_analyzer.sh

📋 스킬 메타데이터:
- 이름: test-generator
- 버전: 1.0.0
- 의존성: vitest, @testing-library/react
- 호출 명령어: /test

⏱️ 변환 시간: 8초

💡 다음 단계:
1. 스킬 검증: cat .claude/skills/test-generator/SKILL.md
2. 테스트 실행: /test
3. 원본 백업: .cursor/rules/testing-strategy.mdc.backup
```

## ❌ 실패 시 출력

```
❌ Prompt → Skill 변환 실패

🔍 원인:
- 원본 프롬프트 형식 오류 (올바른 .mdc 형식 아님)
- 또는: 중복 스킬 이름 (test-generator 이미 존재)
- 또는: .claude/skills/ 디렉토리 권한 없음

💡 해결 방법:
1. 중복 스킬 처리 선택:
   - 덮어쓰기: 기존 스킬 백업 후 새로 생성
   - 새 이름: test-generator-v2로 생성
   - 병합: 기존 스킬에 내용 추가

2. 디렉토리 권한 확인:
   mkdir -p .claude/skills
   chmod u+w .claude/skills

3. 프롬프트 형식 검증:
   - Frontmatter 확인 (---)
   - 마크다운 구조 검증
   - 코드 블록 닫힘 확인

4. 수동 변환:
   - SKILL.md 템플릿 사용
   - 원본 내용을 knowledge/로 복사
   - 스크립트를 tools/로 분리

📚 추가 도움말: .claude/skills/README.md의 스킬 구조 참조
```
