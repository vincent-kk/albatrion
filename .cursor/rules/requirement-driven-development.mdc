---
alwaysApply: false
---

# Requirement-Driven Development Rules

## Overview

This rule defines the process of analyzing planning documents and generating structured development documentation using the EARS (Easy Approach to Requirements Syntax) methodology.

## Project Structure Analysis

**CRITICAL: Before applying any rules, load project-specific configuration**

### 1. Check for Project Structure File

```bash
# Check if .project-structure.yaml exists in project root
if [ -f ".project-structure.yaml" ]; then
  echo "✓ Project structure file found"
else
  echo "⚠️  .project-structure.yaml not found in project root"
  echo "→ Running automatic project structure analysis..."
  # This will trigger analyze-project-structure rule
fi
```

### 2. Auto-Generate if Missing

**IMPORTANT: Use analyze-project-structure.mdc rule**

When `.project-structure.yaml` doesn't exist in project root:

```markdown
AI Execution Steps:
1. Invoke: analyze-project-structure rule
2. The rule will:
   - Scan package.json and lock files
   - Detect project type (monorepo/single-package)
   - Detect package manager (yarn/npm/pnpm/bun)
   - Analyze directory structure
   - Detect tech stack from dependencies
   - Extract commands from package.json scripts
   - Infer path and naming conventions
   - Generate .project-structure.yaml in project root
3. Show generated config to user
4. Ask user: "Project structure detected. Please review .project-structure.yaml"
5. Wait for user confirmation or adjustments
6. Continue with original task

**File Location**: .project-structure.yaml (project root, NOT .cursor/rules/)
```

**Why Project Root?**
- ✅ Version controlled with project
- ✅ Shared across team
- ✅ One source of truth
- ✅ Easy to find and edit

### 3. Load Project Configuration

Throughout this rule file, the following variables are replaced with actual values from `.project-structure.yaml`:

- `{packages_dir}` → `project.structure.packages_dir`
- `{source_dir}` → `project.structure.source_dir`
- `{workspace_command}` → `project.package_manager.workspace_command`
- `{package_name}` → Specific package being worked on
- `{dev_command}` → `project.commands.dev.*`
- `{test_command}` → `project.commands.test.*`
- `{lint_command}` → `project.commands.lint.*`
- `{build_command}` → `project.commands.build.*`

## Tree of Thoughts: Multi-Path Requirements Analysis

**Purpose**: Before writing formal requirements, explore multiple interpretations and design paths to make informed decisions.

### When to Apply ToT in Requirements Analysis

Apply ToT reasoning when:
- User requirements are ambiguous or open to interpretation
- Multiple technical approaches are viable
- Trade-offs between different implementations exist
- Risk of choosing wrong direction is high

### ToT Process for Requirements

#### Step 1: Generate Requirement Interpretations (사고 생성)

For each user story or feature request, generate 3-5 possible interpretations:

```markdown
**User Request**: "사용자가 시간대를 선택할 수 있어야 한다"

**해석 후보 생성**:
- **해석 A**: 단순 체크박스 목록으로 시간대 선택
- **해석 B**: 드래그로 연속된 시간 범위 선택
- **해석 C**: 캘린더 뷰에서 시각적 시간 블록 선택
- **해석 D**: 시작/종료 시간 입력 필드
```

#### Step 2: Evaluate Each Interpretation (사고 평가)

Evaluate each interpretation using scoring criteria:

**평가 기준 (총 100점)**:
- 구현 복잡도 (30점): 낮을수록 높은 점수
- 요구사항 충족도 (30점): 사용자 니즈 충족 정도
- UX 품질 (20점): 사용 편의성
- 유지보수성 (10점): 향후 변경 용이성
- 팀 역량 적합성 (10점): 팀 기술 스택과의 정합성

```markdown
**해석 A 평가**:
- 구현 복잡도: 28/30 (매우 간단)
- 요구사항 충족도: 20/30 (기본 기능만 제공)
- UX 품질: 12/20 (직관적이지만 제한적)
- 유지보수성: 9/10 (단순 구조)
- 팀 역량: 10/10 (표준 HTML)
- **총점: 79/100 (가능함)**

**해석 B 평가**:
- 구현 복잡도: 20/30 (중간 복잡도)
- 요구사항 충족도: 28/30 (우수한 UX)
- UX 품질: 18/20 (직관적이고 효율적)
- 유지보수성: 7/10 (상태 관리 복잡)
- 팀 역량: 9/10 (React DnD 경험 있음)
- **총점: 82/100 (확실함)** ✅

**해석 C 평가**:
- 구현 복잡도: 15/30 (높은 복잡도)
- 요구사항 충족도: 25/30 (좋은 UX)
- UX 품질: 17/20 (시각적으로 우수)
- 유지보수성: 6/10 (복잡한 구조)
- 팀 역량: 5/10 (캘린더 라이브러리 미경험)
- **총점: 68/100 (가능함)**

**해석 D 평가**:
- 구현 복잡도: 27/30 (간단)
- 요구사항 충족도: 18/30 (기본 기능)
- UX 품질: 10/20 (불편함)
- 유지보수성: 8/10 (간단)
- 팀 역량: 10/10 (기본 HTML)
- **총점: 73/100 (가능함)**
```

#### Step 3: Select and Lookahead (선택 및 전망)

**평가 결과**:
- 🏆 **1순위**: 해석 B (82점 - 확실함)
- 🥈 **2순위**: 해석 A (79점 - 안전한 대안)
- 🥉 **3순위**: 해석 D (73점 - 최소 기능)
- ❌ **제거**: 해석 C (68점 - 복잡도 대비 효과 낮음)

**선택**: 해석 B (드래그 기반 시간 범위 선택)

**Lookahead (다음 의사결정 예측)**:
- 다음 결정: 드래그 라이브러리 선택 (react-dnd vs react-beautiful-dnd)
- 예상 복잡도: 중간
- 리스크: 모바일 터치 지원 이슈 가능성
- **Backtrack Plan**: 만약 구현 중 막히면 → 해석 A로 전환 (시간 손실 최소화)

#### Step 4: Document Decision Rationale (결정 근거 문서화)

```markdown
## 의사결정 기록

### 결정: 시간대 선택 방식
- **선택**: 드래그 기반 시간 범위 선택 (해석 B)
- **점수**: 82/100
- **근거**:
  - UX와 요구사항 충족도가 가장 높음
  - 팀이 React DnD 경험 보유
  - 구현 복잡도가 수용 가능 범위
- **대안**: 단순 체크박스 (해석 A, 79점) - 백트래킹 시 사용
- **제거 옵션**: 캘린더 뷰 (복잡도 과다), 입력 필드 (UX 불량)
- **리스크**: 모바일 터치 이슈 → 대안 A로 전환 가능
```

### ToT Benefits in Requirements Phase

**장점**:
- ✅ **체계적 의사결정**: 직관이 아닌 평가 기준 기반
- ✅ **리스크 관리**: 대안 확보로 실패 대비
- ✅ **추적 가능성**: 왜 이 선택을 했는지 명확
- ✅ **팀 합의**: 평가 기준으로 객관적 논의 가능

**적용 시점**:
- 요구사항 불명확 시
- 여러 구현 방법 존재 시
- 높은 리스크 또는 비용 관련 결정 시

---

## EARS Methodology

### Requirement Types

#### 1. Ubiquitous Requirements (일반 요구사항)

- Format: `The <system> shall <requirement>`
- Used for general, always-active requirements
- Example: "The system shall validate user input before processing"

#### 2. Event-Driven Requirements (이벤트 기반)

- Format: `WHEN <trigger> the <system> shall <requirement>`
- Used for requirements triggered by specific events
- Example: "WHEN user clicks submit button, the system shall save the form data"

#### 3. Unwanted Behaviors (금지 행동)

- Format: `The <system> shall NOT <unwanted behavior>`
- Used to explicitly prevent certain behaviors
- Example: "The system shall NOT allow duplicate email registrations"

#### 4. State-Driven Requirements (상태 기반)

- Format: `WHILE <in state> the <system> shall <requirement>`
- Used for requirements active during specific states
- Example: "WHILE in maintenance mode, the system shall display maintenance message"

#### 5. Optional Requirements (선택 기능)

- Format: `WHERE <feature is included> the <system> shall <requirement>`
- Used for optional or configurable features
- Example: "WHERE premium subscription is active, the system shall enable advanced features"

#### 6. Complex Requirements (복합 요구사항)

- Combination of above formats
- Example: "WHEN user logs in, IF premium subscription is active, the system shall display premium dashboard"

## Pre-Development Project Analysis

### CRITICAL: Before Starting Any Task

**ALWAYS perform these checks BEFORE creating any files or writing code:**

#### 1. Load Project Structure Configuration

```bash
# Load .project-structure.yaml
# Extract: packages_dir, source_dir, tech_stack, path_conventions
```

#### 2. Identify Task Type (New Feature vs Existing Feature Enhancement)

```bash
# Check if related pages/components already exist
# Use {packages_dir} and {source_dir} from config
find {packages_dir}/*/src/pages -type d -name "*{feature-name}*" 2>/dev/null || \
find {source_dir}/pages -type d -name "*{feature-name}*" 2>/dev/null

find {packages_dir}/*/src/components -type d -name "*{feature-name}*" 2>/dev/null || \
find {source_dir}/components -type d -name "*{feature-name}*" 2>/dev/null

# Check for existing API definitions (technology-specific)
# For GraphQL projects:
find {packages_dir}/*/src/api/graphql -type f -name "*.graphql" 2>/dev/null | grep -i {feature-name}

# For REST projects:
find {packages_dir}/*/src/api/routes -type f -name "*.ts" 2>/dev/null | grep -i {feature-name}
```

**Decision Matrix:**
- **Existing Feature**: Found files → ENHANCE existing code, DO NOT create new files
- **New Feature**: No files found → CREATE new structure following project patterns

#### 3. Understand Project Structure Patterns

**Analyze from .project-structure.yaml:**

```yaml
# Example path_conventions:
path_conventions:
  component_path: "{packages_dir}/app/src/components/{ComponentName}/{ComponentName}.tsx"
  page_path: "{packages_dir}/app/src/pages/{PageName}/{PageName}.page.tsx"
  api_path: "{packages_dir}/api/src/{ModuleName}/{ModuleName}.resolver.ts"
```

**Follow project-specific patterns defined in configuration.**

#### 4. Verify Existing Resources by Tech Stack

**For GraphQL projects (if tech_stack.backend.api_style === "graphql"):**

```bash
# Check Order:
1. {packages_dir}/{backend_package}/src/graphql/{Entity}/queries.graphql
2. {packages_dir}/{backend_package}/src/graphql/{Entity}/mutations.graphql
3. {packages_dir}/{backend_package}/src/graphql/fragments.graphql

# Generated Types Location (check custom.generate_types command):
# Usually: interface.ts or generated.ts
```

**For REST projects (if tech_stack.backend.api_style === "rest"):**

```bash
# Check for existing routes:
find {packages_dir}/{backend_package}/src/routes -type f -name "*{entity}*.ts"
```

#### 5. Check State Management Patterns (Tech Stack Specific)

**Consult tech_stack.state_management from config:**

```typescript
// Example for Apollo Client + Jotai:
// ✅ CORRECT: Use Apollo Client hooks for server data
const { data } = useQuery(QUERY);
const [mutate] = useMutation(MUTATION);

// ✅ CORRECT: Use Jotai for UI-only state
const [isOpen, setIsOpen] = useAtom(uiAtom);

// ❌ WRONG: Mixing concerns
const eventDataAtom = atom(null); // Should use Apollo Cache instead
```

**For other state management (Redux, Zustand, MobX):**
- Follow project-specific patterns from existing code
- Check state_management configuration

#### 6. Verify Existing Mock Data (Tech Stack Specific)

**For MSW (if testing.mocking === "msw"):**

```bash
# Check if mock data exists
find {packages_dir}/*/mocks -type f -name "*{entity}*"
```

**For other mocking libraries:**
- Check testing.mocking configuration
- Follow existing mock patterns

### Project-Specific Constraints

**Load from .project-structure.yaml and respect:**

1. **API Schema Ownership**: Check if backend owns schema (common in team projects)
2. **Type Generation**: Use commands.custom.generate_types if defined
3. **Shared Utilities**: Check for existing helper directories before creating new ones
4. **Naming Conventions**: Follow naming_conventions.* from config

## Role-Based Development Focus

### Frontend Developer Focus
**IMPORTANT**: When the developer identifies as a Frontend Developer, the requirement-driven development process should focus primarily on frontend implementation while treating backend components as existing dependencies.

#### Frontend-First Approach:
- **Backend Dependencies**: Assume GraphQL APIs and schemas are provided or will be provided by backend team
- **Mock-Driven Development**: Use MSW (Mock Service Worker) for all API interactions during development
- **Component-First Design**: Focus on React components, Storybook stories, and state management
- **API Integration**: Treat GraphQL queries/mutations as external dependencies to be consumed
- **Existing Resources**: ALWAYS check for existing GraphQL queries, types, and components BEFORE creating new ones

#### Modified Document Structure for Frontend Focus:
```
.tasks/frontend_{task_name}_{yyyyMMdd}/
├── 01_requirements.md      # EARS-based requirements analysis (Frontend-focused)
├── 02_design.md            # Frontend technical design document
├── 03_plan.md              # Frontend implementation plan
├── 04_guideline.md         # Frontend execution guidelines
└── assets/                 # Images and UI specifications
    ├── mockups/           # UI mockups and wireframes
    ├── diagrams/          # Frontend architecture diagrams
    └── specs/             # Design specifications
```

## Document Structure

### Directory Organization

```
.tasks/{type}_{task_name}_{yyyyMMdd}/
├── 01_requirements.md      # EARS-based requirements analysis
├── 02_design.md            # Technical design document
├── 03_plan.md              # Implementation plan with tasks
├── 04_guideline.md         # Execution guidelines
└── assets/                 # Images and UI specifications
    ├── mockups/           # UI mockups and wireframes
    ├── diagrams/          # Technical diagrams
    └── specs/             # Design specifications
```

### 1. 요구사항 문서 (01_requirements.md) - 한글 작성

#### 작성 원칙

1. **사용자 중심 접근**: 모든 요구사항은 사용자 가치를 명확히 해야 함
2. **검증 가능성**: 각 요구사항은 테스트 가능한 수락 기준을 가져야 함
3. **명확성**: 모호한 표현 금지, 구체적인 조건과 결과 명시
4. **추적성**: 고유 ID로 설계 및 작업과 연결
5. **완전성**: 모든 사용 사례를 커버해야 함

```markdown
# 요구사항 분석 - {작업명}

## 개요

**목적**: 이 기능이 해결하는 문제와 제공하는 가치를 2-3문장으로 명확히 설명
**범위**: 포함되는 것과 포함되지 않는 것을 명시

## 이해관계자

- 사용자: [대상 사용자 - 구체적으로]
- 시스템: [영향받는 시스템 컴포넌트]
- 외부: [서드파티 통합 또는 의존성]

## 기능 요구사항 (EARS 형식)

### 요구사항 작성 가이드

**구조**: 기능 > 요구사항 > 수락 기준
- **기능**: 관련된 요구사항들을 그룹화 (번호 없음)
- **요구사항**: 각각 고유 ID (REQ-X.Y) + 사용자 스토리 + EARS 수락 기준
- **ID 체계**: REQ-[기능번호].[요구사항번호] (예: REQ-1.1, REQ-1.2)
- **선택적 요구사항**: REQ-O로 시작 (예: REQ-O1.1)

### 기능 1: [기능명]

> 이 기능이 제공하는 가치를 1-2문장으로 설명

#### REQ-1.1: [구체적인 요구사항 제목]

- **사용자 스토리**: As a [역할], I want [기능], so that [이점]
- **수락 기준**: WHEN [조건] THEN 시스템은 [동작]을 해야 한다
- **우선순위**: High/Medium/Low

#### REQ-1.2: [구체적인 요구사항 제목]

- **사용자 스토리**: As a [역할], I want [기능], so that [이점]
- **수락 기준**: IF [전제조건] THEN 시스템은 [동작]을 해야 한다
- **우선순위**: High/Medium/Low

#### REQ-1.3: [금지 행동]

- **사용자 스토리**: As a [역할], I want [보호받고 싶은 것], so that [이점]
- **수락 기준**: 시스템은 [금지된 행동]을 하지 않아야 한다
- **우선순위**: High/Medium/Low

### 기능 2: [기능명]

> 이 기능이 제공하는 가치를 1-2문장으로 설명

#### REQ-2.1: [구체적인 요구사항 제목]

- **사용자 스토리**: As a [역할], I want [기능], so that [이점]
- **수락 기준**: WHILE [상태] THEN 시스템은 [동작]을 해야 한다
- **우선순위**: High/Medium/Low

### 기능 3: [선택적 기능명] (Optional)

> 이 기능이 제공하는 가치를 1-2문장으로 설명

#### REQ-O3.1: [구체적인 요구사항 제목]

- **사용자 스토리**: As a [역할], I want [기능], so that [이점]
- **수락 기준**: WHERE [조건]인 경우, 시스템은 [동작]을 해야 한다
- **우선순위**: Low

---

### 실제 작성 예시

### 기능 1: 시간대 투표

> 참석자가 가능한 시간대를 선택하여 투표할 수 있는 기능

#### REQ-1.1: 시간대 선택 UI 피드백

- **사용자 스토리**: As a 참석자, I want 선택한 시간대를 시각적으로 확인하고 싶다, so that 내가 어떤 시간대를 선택했는지 명확히 알 수 있다
- **수락 기준**: WHEN 사용자가 시간대를 클릭할 때 THEN 시스템은 해당 시간대를 선택된 상태로 표시해야 한다
- **우선순위**: High

#### REQ-1.2: 투표 저장

- **사용자 스토리**: As a 참석자, I want 내 투표를 저장하고 싶다, so that 나중에 다시 접속해도 내 선택이 유지된다
- **수락 기준**: WHEN 사용자가 저장 버튼을 클릭할 때 THEN 시스템은 선택된 시간대 목록을 서버에 저장해야 한다
- **우선순위**: High

#### REQ-1.3: 중복 투표 방지

- **사용자 스토리**: As a 이벤트 주최자, I want 한 사용자가 여러 번 투표하지 못하게 하고 싶다, so that 투표 결과가 공정하다
- **수락 기준**: 시스템은 동일한 사용자의 중복 투표를 허용하지 않아야 한다
- **우선순위**: High

## 비기능 요구사항

> 비기능 요구사항도 REQ-NF로 시작하는 ID 부여

### 성능

#### REQ-NF1: 페이지 로드 성능
- **기준**: 초기 페이지 로드 시간 < 2초 (3G 네트워크 기준)
- **측정**: Lighthouse Performance 점수 > 90
- **적용 범위**: 모든 주요 페이지 (홈, 이벤트 상세, 투표 페이지)

#### REQ-NF2: API 응답 성능
- **기준**: GraphQL 쿼리 응답 시간 < 500ms (P95)
- **측정**: 서버 로그 분석
- **적용 범위**: 모든 GraphQL 쿼리/뮤테이션

### 보안

#### REQ-NF3: 인증/인가
- **기준**: 모든 보호된 API는 유효한 토큰 필요
- **구현**: JWT 토큰 기반 인증, 만료 시간 24시간
- **적용 범위**: 투표, 이벤트 생성/수정 API

#### REQ-NF4: XSS/CSRF 방지
- **기준**: 사용자 입력은 모두 sanitize 처리
- **구현**: React의 자동 이스케이프 + DOMPurify 라이브러리
- **적용 범위**: 모든 사용자 입력 필드

### 사용성

#### REQ-NF5: 접근성
- **기준**: WCAG 2.1 AA 준수
- **측정**: Lighthouse Accessibility 점수 > 90
- **필수 항목**: 키보드 네비게이션, 스크린 리더 지원, 색상 대비 4.5:1 이상

#### REQ-NF6: 모바일 반응형
- **기준**: 320px ~ 1920px 화면 크기 지원
- **측정**: 주요 기기에서 수동 테스트 (iPhone SE, iPad, Desktop)
- **적용 범위**: 모든 페이지

### 호환성

#### REQ-NF7: 브라우저 지원
- **기준**: Chrome 90+, Safari 14+, Firefox 88+, Edge 90+
- **측정**: BrowserStack 크로스 브라우저 테스트
- **적용 범위**: 모든 기능

#### REQ-NF8: 기기 지원
- **기준**: 데스크톱, 모바일 (iOS/Android), 태블릿
- **측정**: 실제 기기 테스트
- **적용 범위**: 모든 기능

## 전체 완료 기준

**이 기능이 완료되었다고 판단하는 기준**:
- [ ] 모든 High 우선순위 요구사항 (REQ-X.Y) 구현 완료
- [ ] 각 요구사항의 EARS 수락 기준 충족 확인
- [ ] 비기능 요구사항 지표 측정 및 목표 달성
- [ ] 정상 플로우 + 주요 에러 케이스 처리 완료
- [ ] 사용자 피드백 (로딩, 성공, 에러) 명확히 표시

**참고**: 개별 요구사항의 수락 기준은 각 REQ-X.Y 항목 참조

## 의존성

### 외부 API
- API 이름, 버전, 엔드포인트
- 필요한 인증 방식

### 라이브러리
- 라이브러리 이름 및 버전
- 사용 목적

### 기존 기능
- 의존하는 기존 컴포넌트/모듈
- 영향받는 기존 기능

## 위험 및 완화 방안

### 위험 1: [구체적인 위험 설명]
- **영향도**: High/Medium/Low
- **발생 가능성**: High/Medium/Low
- **완화 방안 1**: [구체적인 전략]
- **완화 방안 2**: [대안 전략]

### 위험 2: [구체적인 위험 설명]
- **영향도**: High/Medium/Low
- **발생 가능성**: High/Medium/Low
- **완화 방안**: [구체적인 전략]

## 기술 스택

**명시적으로 나열**:
- Frontend: React 18, TypeScript, Vite
- State Management: Jotai, Apollo Client
- UI Library: Ant Design Mobile
- Testing: Vitest, MSW

## 참고 사항

- 프로덕션 배포 시 고려사항
- 향후 확장 가능성
- 알려진 제약사항
```

### 2. 설계 문서 (02_design.md) - 한글 작성

#### Frontend Developer Version:
````markdown
# 프론트엔드 기술 설계 - {작업명}

## 아키텍처 개요

프론트엔드 중심 아키텍처 설명 (React + Jotai + Apollo Client)

## 설계 대안 평가 (Tree of Thoughts)

**Purpose**: 주요 설계 결정마다 여러 옵션을 체계적으로 평가하여 최적 선택

### 의사결정 포인트별 ToT 적용

#### 설계 결정 1: [예: State Management Library]

**Context**: 전역 상태 관리가 필요한 컴포넌트 간 데이터 공유

**후보 옵션**:

| 옵션 | 장점 | 단점 | 평가 점수 |
|------|------|------|-----------|
| **Option A: Jotai** | - 경량 (2.9KB)<br>- React 친화적<br>- 학습 곡선 낮음 | - 대규모 앱 구조화 어려움<br>- DevTools 제한적 | 85/100 (확실함) |
| **Option B: Redux Toolkit** | - 강력한 구조<br>- 우수한 DevTools<br>- 생태계 풍부 | - 보일러플레이트 많음<br>- 학습 곡선 높음 | 75/100 (가능함) |
| **Option C: Zustand** | - 간단한 API<br>- 성능 우수<br>- TypeScript 지원 좋음 | - 생태계 작음<br>- 팀 경험 없음 | 70/100 (가능함) |

**평가 기준**:
- 프로젝트 규모 적합성 (30점)
- 팀 경험/학습 곡선 (25점)
- 성능 (20점)
- 생태계/지원 (15점)
- TypeScript 지원 (10점)

**선택**: Option A (Jotai)
- **근거**: 중소 규모 프로젝트, 팀이 이미 경험 보유, 빠른 개발 가능
- **Lookahead**: 추후 규모 확장 시 Redux로 마이그레이션 고려 (비용: 3-5일)
- **대안**: Option B (Redux Toolkit) - 엔터프라이즈급 확장 필요 시

#### 설계 결정 2: [예: Component Structure Pattern]

**Context**: 재사용 가능한 컴포넌트 구조 설계

**후보 옵션**:

| 옵션 | 구조 | 장점 | 단점 | 평가 |
|------|------|------|------|------|
| **Option A: Atomic Design** | atoms → molecules → organisms | 체계적 구조, 재사용성 높음 | 초기 설정 시간 필요 | 80/100 |
| **Option B: Feature-based** | features/{feature}/components | 기능별 응집도 높음, 찾기 쉬움 | 컴포넌트 중복 가능 | 78/100 |
| **Option C: Flat Structure** | components/* | 단순함, 빠른 시작 | 규모 증가 시 혼란 | 65/100 |

**선택**: Option A (Atomic Design)
- **근거**: 디자인 시스템 기반 개발, 장기 유지보수 고려
- **Backtrack Plan**: 3개월 내 컴포넌트 50개 이하면 Option B로 단순화

### 설계 의사결정 문서화

모든 주요 설계 결정은 다음 형식으로 문서화:

```markdown
### 설계 결정 기록 (Architecture Decision Record)

**결정 ID**: ADR-001
**날짜**: YYYY-MM-DD
**결정자**: [역할]

**Context**: [왜 이 결정이 필요한가?]

**검토된 옵션**:
- Option A: [설명] (점수: X/100)
- Option B: [설명] (점수: Y/100)
- Option C: [설명] (점수: Z/100)

**결정**: Option A
**근거**: [평가 기준별 우위]
**트레이드오프**: [포기한 것]
**리스크**: [예상 문제점]
**대응 계획**: [리스크 발생 시 대안]
**대안**: Option B (백트래킹 시)
```

## 컴포넌트 설계

### UI 컴포넌트 구조

- 컴포넌트 계층 구조
- Props 인터페이스 정의
- 재사용 가능한 컴포넌트

### 상태 관리 전략

- Jotai atoms 설계
- Apollo Client 캐시 전략
- 로컬 상태 vs 서버 상태

### GraphQL 통합

- 필요한 Query/Mutation 정의
- MSW 모의 핸들러
- 타입 안전성 확보

## 데이터 흐름

1. 사용자 상호작용
2. 컴포넌트 상태 업데이트
3. GraphQL 요청
4. 응답 처리 및 UI 업데이트

## 성능 고려사항

- 컴포넌트 최적화 (React.memo, useMemo)
- 번들 크기 최적화
- 이미지 최적화
- 코드 스플리팅

## 테스트 전략

- 컴포넌트 단위 테스트 (Vitest)
- Storybook 시각적 테스트
- MSW 기반 통합 테스트

````

#### Full-Stack Version:
````markdown
# 기술 설계 - {작업명}

## 아키텍처 개요

상위 수준 아키텍처 설명

## 컴포넌트 설계

### 프론트엔드 컴포넌트

- 컴포넌트 구조
- 상태 관리 전략 (Jotai atoms)
- GraphQL 쿼리/뮤테이션

### 백엔드 서비스

- NestJS 모듈
- GraphQL 리졸버
- 데이터 모델

## 데이터 흐름

1. 사용자 상호작용
2. 프론트엔드 처리
3. API 호출
4. 백엔드 처리
5. 응답 처리

## 데이터베이스 스키마 변경

- 새로운 테이블/컬렉션
- 수정된 필드
- 인덱스

## API 설계

### GraphQL 스키마

```graphql
type NewType {
  field: Type
}
```
````

### REST 엔드포인트 (해당 시)

- POST /api/endpoint

## 보안 고려사항

- 인증 요구사항
- 인가 규칙
- 데이터 검증

## 성능 고려사항

- 캐싱 전략
- 쿼리 최적화
- 번들 크기 영향

## 테스트 전략

- 유닛 테스트
- 통합 테스트
- E2E 테스트

````

### 3. 구현 계획 (03_plan.md) - 한글 작성

#### 작성 원칙

1. **실행 가능성**: 모든 작업은 코드 작성/수정/테스트에만 집중
2. **작업 크기**: 각 작업은 1-4시간 내 완료 가능하도록 분할
3. **요구사항 추적**: 각 작업에 관련 요구사항 ID 명시
4. **선택적 작업 구분**: 핵심 기능(필수) vs 보조 작업(선택사항*)
5. **점진적 구현**: 작업 순서는 의존성을 고려하여 배치
6. **명확한 완료 기준**: 각 작업의 완료 조건을 명확히 정의

#### 작업 형식 규칙

**상위 작업 (그룹)**:
```markdown
- [ ] X. 상위 작업 제목
  - 이 작업 그룹의 목적과 범위를 1-2문장으로 설명
  - _Requirements: REQ-X.Y, REQ-Z.W_
```

**하위 작업 (실제 구현)**:
```markdown
- [ ] X.1 하위 작업 제목
  - **파일**: `packages/app/src/...` (생성/수정할 파일 경로)
  - **내용**: 무엇을 구현하는지 (예: "시간대 선택 UI 컴포넌트 구현")
  - **방법**: 어떻게 구현하는지 (예: "Ant Design Checkbox 사용, Jotai로 상태 관리")
  - **완료**: 어떻게 확인하는지 (예: "시간대 클릭 시 UI 업데이트 확인")
  - _Requirements: REQ-X.Y_
```

**선택적 작업 (테스트, 최적화 등)**:
```markdown
- [ ]* X.2 선택적 작업 제목
  - **파일**: `packages/app/src/.../__tests__/...`
  - **내용**: 테스트 또는 최적화 내용
  - **방법**: 사용할 도구/라이브러리
  - **완료**: 테스트 통과 또는 성능 목표 달성
  - _Requirements: REQ-X.Y_
```

**작성 팁**:
- **파일**: 경로만 간결하게 (설명 불필요)
- **내용**: "~을 구현" 형태로 간결하게
- **방법**: 핵심 기술/패턴만 나열 (상세 설명은 설계 문서 참조)
- **완료**: 검증 가능한 기준 (예: "~가 동작함", "~가 표시됨")

---

### 실제 작성 예시

```markdown
## 단계 3: 핵심 UI 컴포넌트 구현

- [ ] 3. 시간대 선택 컴포넌트 개발
  - 사용자가 시간대를 선택하고 투표할 수 있는 UI 컴포넌트 구현
  - _Requirements: REQ-1.1, REQ-1.2_

- [ ] 3.1 TimeSlotSelector 컴포넌트 생성
  - **파일**: `packages/app/src/components/TimeSlotSelector/TimeSlotSelector.tsx`
  - **내용**: 시간대 선택 UI 컴포넌트 구현
  - **방법**: Ant Design Mobile Checkbox 사용, 선택 상태는 Jotai atom으로 관리
  - **완료**: 시간대 클릭 시 체크박스 토글 및 선택 상태 업데이트 확인
  - _Requirements: REQ-1.1_

- [ ] 3.2 투표 저장 로직 구현
  - **파일**: `packages/app/src/components/TimeSlotSelector/TimeSlotSelector.tsx`
  - **내용**: 선택된 시간대를 서버에 저장하는 기능 구현
  - **방법**: Apollo Client의 useVoteMutation 훅 사용, 저장 버튼 클릭 시 실행
  - **완료**: 저장 버튼 클릭 시 GraphQL mutation 호출 및 성공 토스트 표시 확인
  - _Requirements: REQ-1.2_

- [ ]* 3.3 TimeSlotSelector 컴포넌트 테스트
  - **파일**: `packages/app/src/components/TimeSlotSelector/__tests__/TimeSlotSelector.test.tsx`
  - **내용**: 시간대 선택 및 저장 로직 단위 테스트
  - **방법**: Vitest + React Testing Library, MSW로 API 모킹
  - **완료**: 모든 테스트 케이스 통과 (선택, 저장, 에러 처리)
  - _Requirements: REQ-1.1, REQ-1.2_
```

#### 비코딩 작업 제외 규칙

**명확한 기준**: "코드 에디터에서 파일을 열어 작업하는가?"

**✅ 포함할 작업 (코딩 활동)**:
- 파일 생성/수정 (`.ts`, `.tsx`, `.css`, `.graphql` 등)
- 함수/컴포넌트 구현
- 테스트 코드 작성
- 설정 파일 수정 (`.json`, `.yaml`, `.config.ts` 등)
- 타입 정의 (`.d.ts`, `interface`, `type`)
- 스타일링 (`.css`, `.scss`, `.module.css`)
- JSDoc/코드 주석 작성
- GraphQL 스키마/쿼리 작성
- MSW 모의 핸들러 작성

**❌ 제외할 작업 (비코딩 활동)**:
- 배포 (Deployment) - CI/CD 실행, 서버 배포
- 사용자 테스트 (User Testing) - 실제 사용자 피드백 수집
- 성능 모니터링 (Performance Monitoring) - 프로덕션 메트릭 확인
- 마크다운 문서 작성 (README, 기획 문서 등) - 단, 코드 문서화는 포함
- 회의 및 논의 - 단, 코드 리뷰는 별도 프로세스
- 디자인 작업 (Figma, Sketch 등)

**⚠️ 경계 케이스 (판단 필요)**:
- **Storybook 스토리**: ✅ 포함 (`.stories.tsx` 파일 작성)
- **README 업데이트**: ❌ 제외 (단, API 문서 자동 생성은 포함)
- **환경 변수 설정**: ✅ 포함 (`.env` 파일 수정)
- **데이터베이스 마이그레이션**: ✅ 포함 (마이그레이션 파일 작성)

#### Frontend Developer Version:
```markdown
# 프론트엔드 구현 계획 - {작업명}

## 단계 1: 설정 및 준비
- [ ] 작업 1.1: 환경 설정 및 브랜치 생성
- [ ] 작업 1.2: GraphQL 스키마 요구사항 정의
- [ ] 작업 1.3: MSW 모의 데이터 구조 설계

## 단계 2: 컴포넌트 기초 개발
- [ ] 작업 2.1: Jotai atoms 구조 생성
- [ ] 작업 2.2: 재사용 가능한 기본 컴포넌트 생성
- [ ] 작업 2.3: Storybook 스토리 작성
- [ ] 작업 2.4: TypeScript 인터페이스 정의

## 단계 3: 핵심 UI 컴포넌트 구현
- [ ] 작업 3.1: 주요 컴포넌트 구현
- [ ] 작업 3.2: MSW 핸들러 구현
- [ ] 작업 3.3: 컴포넌트 단위 테스트
- [ ] 작업 3.4: 반응형 레이아웃 구현

## 단계 4: 상태 관리 및 데이터 통합
- [ ] 작업 4.1: GraphQL 쿼리/뮤테이션 정의
- [ ] 작업 4.2: Apollo Client 설정
- [ ] 작업 4.3: Jotai atoms와 GraphQL 연동
- [ ] 작업 4.4: 오류 처리 및 로딩 상태

## 단계 5: 통합 및 최적화
- [ ] 작업 5.1: 페이지 라우팅 연결
- [ ] 작업 5.2: 성능 최적화 (메모이제이션, 코드 스플리팅)
- [ ] 작업 5.3: 접근성 개선
- [ ] 작업 5.4: 모바일 UX 최적화

## 단계 6: 테스트 및 품질 보증
- [ ] 작업 6.1: 통합 테스트 작성
- [ ] 작업 6.2: Storybook 시각적 테스트
- [ ] 작업 6.3: 크로스 브라우저 테스트
- [ ] 작업 6.4: 성능 측정 및 최적화

## 단계 7: 문서화 및 마무리 (필수)
- [ ] 작업 7.1: 계획 문서 완료 상태 업데이트
- [ ] 작업 7.2: 진행 기록 생성 (progress_log.md)
- [ ] 작업 7.3: 최종 상태 리포트 생성 (final_status_report.md)
- [ ] 작업 7.4: 문서 커밋 및 프로젝트 완료

## 타임라인
- 단계 1: 1일차
- 단계 2-3: 2-3일차
- 단계 4: 4일차
- 단계 5: 5일차
- 단계 6: 6일차
- 단계 7: 6일차 (마무리)

## 완료 기준
- [ ] 모든 프론트엔드 테스트 통과
- [ ] 코드 리뷰 완료
- [ ] Storybook 스토리 완성
- [ ] 린트 에러 없음
- [ ] 모바일 성능 벤치마크 충족
- [ ] 진행 기록 및 최종 리포트 생성 완료
```

#### Full-Stack Version:
```markdown
# 구현 계획 - {작업명}

## 단계 1: 설정 및 준비
- [ ] 작업 1.1: 환경 설정
- [ ] 작업 1.2: 의존성 설치
- [ ] 작업 1.3: 초기 프로젝트 구조

## 단계 2: 백엔드 개발
- [ ] 작업 2.1: GraphQL 스키마 정의
- [ ] 작업 2.2: NestJS 모듈 생성
- [ ] 작업 2.3: 리졸버 구현
- [ ] 작업 2.4: 서비스 레이어 구현
- [ ] 작업 2.5: 유닛 테스트

## 단계 3: 프론트엔드 개발
- [ ] 작업 3.1: 컴포넌트 구조 생성
- [ ] 작업 3.2: Storybook 스토리
- [ ] 작업 3.3: MSW 모의 핸들러
- [ ] 작업 3.4: 상태 관리 (Jotai)
- [ ] 작업 3.5: GraphQL 통합
- [ ] 작업 3.6: 컴포넌트 테스트

## 단계 4: 통합
- [ ] 작업 4.1: 프론트엔드-백엔드 통합
- [ ] 작업 4.2: 오류 처리
- [ ] 작업 4.3: 로딩 상태
- [ ] 작업 4.4: 통합 테스트

## 단계 5: 개선 및 최적화
- [ ] 작업 5.1: UI/UX 개선
- [ ] 작업 5.2: 성능 최적화
- [ ] 작업 5.3: 접근성
- [ ] 작업 5.4: 코드 리뷰 준비

## 단계 6: 문서화 및 마무리 (필수)
- [ ] 작업 6.1: 계획 문서 완료 상태 업데이트
- [ ] 작업 6.2: 진행 기록 생성 (progress_log.md)
- [ ] 작업 6.3: 최종 상태 리포트 생성 (final_status_report.md)
- [ ] 작업 6.4: 문서 커밋 및 프로젝트 완료

## 타임라인
- 단계 1: 1일차
- 단계 2: 2-3일차
- 단계 3: 3-4일차
- 단계 4: 5일차
- 단계 5: 6일차
- 단계 6: 6일차 (마무리)

## 완료 기준
- [ ] 모든 테스트 통과
- [ ] 코드 리뷰 완료
- [ ] 문서 업데이트
- [ ] 린트 에러 없음
- [ ] 성능 벤치마크 충족
- [ ] 진행 기록 및 최종 리포트 생성 완료
````

### 4. 실행 가이드라인 (04_guideline.md) - 한글 작성

#### Frontend Developer Version:
````markdown
# 프론트엔드 실행 가이드라인 - {작업명}

## 사전 실행 체크리스트

- [ ] `nvm use` 실행하여 올바른 Node 버전 사용
- [ ] develop 브랜치에서 최신 변경사항 가져오기
- [ ] 피처 브랜치 생성: `git checkout -b feature/issue-{번호}`
- [ ] 모든 의존성 설치 확인: `yarn install`

## Frontend Development Commands

```bash
# Start frontend development servers
yarn app dev
yarn app storybook

# Generate types after GraphQL schema changes (provided by backend)
yarn common generate-types

# Run frontend tests
yarn app test

# Lint and format frontend code
yarn app lint
yarn common format-types

# Build frontend
yarn app build
yarn app build-storybook
```

## MSW 기반 개발 워크플로우

### 1. GraphQL 스키마 요구사항 정의
- 필요한 Query/Mutation 인터페이스 명세
- 백엔드 팀과 API 계약 협의

### 2. MSW 모의 핸들러 구현
- `packages/app/mocks/handlers/` 에서 GraphQL 응답 모의
- 실제 백엔드 개발과 독립적으로 UI 개발 진행

### 3. Storybook 우선 개발
- 컴포넌트를 Storybook에서 먼저 개발
- MSW 데이터로 다양한 상태 시나리오 테스트

### 4. 실제 API 연동
- 백엔드 API 준비 완료 시 MSW → 실제 API 전환
````

#### Full-Stack Version:
````markdown
# 실행 가이드라인 - {작업명}

## 사전 실행 체크리스트

- [ ] `nvm use` 실행하여 올바른 Node 버전 사용
- [ ] develop 브랜치에서 최신 변경사항 가져오기
- [ ] 피처 브랜치 생성: `git checkout -b feature/issue-{번호}`
- [ ] 모든 의존성 설치 확인: `yarn install`

## Development Commands

```bash
# Start development servers
yarn api dev
yarn app dev
yarn app storybook

# Generate types after GraphQL changes
yarn common generate-types
yarn api generate:graphql

# Run tests
yarn app test
yarn api test

# Lint and format
yarn app lint
yarn api lint
yarn common format-types
```
````

## 커밋 가이드라인

### 다음 시점에 커밋:

1. GraphQL 스키마 변경 후
2. 백엔드 모듈 구현 후
3. 컴포넌트 생성 후
4. 상태 관리 설정 후
5. 테스트 구현 후
6. 버그 수정 후

### 커밋 메시지 형식:

- `feat: 새로운 기능 추가`
- `fix: 버그 수정 설명`
- `refactor: 리팩토링 설명`
- `test: 테스트 추가/수정`
- `docs: 문서 업데이트`
- `style: 코드 포맷팅`
- `chore: 빌드/설정 변경`

## 품질 검사

### 각 커밋 전:

```bash
# 린트 실행
yarn app lint && yarn api lint

# 테스트 실행
yarn app test && yarn api test

# 빌드 확인
yarn app build && yarn api build
```

## 오류 처리 절차

### 빌드 오류:

1. TypeScript 컴파일 에러 확인
2. 생성된 타입이 최신인지 확인
3. import 경로 확인

### 테스트 실패:

1. 로컬에서 테스트 실행하여 재현
2. 모의 데이터가 스키마와 일치하는지 확인
3. MSW 핸들러가 올바르게 설정되었는지 확인

### GraphQL 오류:

1. 타입 재생성: `yarn common generate-types`
2. 스키마 호환성 확인
3. 리졸버 구현 확인

## 문서화 요구사항

- 관련 README 파일 업데이트
- 복잡한 함수에 JSDoc 주석 추가
- Storybook 스토리 업데이트
- API 변경사항 문서화

## 리뷰 준비

- GitHub diff 보기로 자체 리뷰
- 모든 수락 기준 충족 확인
- PR 설명 업데이트:
  - 변경사항 요약
  - UI 변경 시 스크린샷
  - 테스트 지침
  - 주요 변경사항 (있는 경우)

````

## 에셋 관리

### 지원되는 에셋 유형
1. **이미지**: PNG, JPG, SVG, GIF
   - UI 목업은 `assets/mockups/`에 저장
   - 기술 다이어그램은 `assets/diagrams/`에 저장

2. **Design Files**:
   - Figma links: Include in requirements.md
   - Sketch files: Store in assets/
   - Adobe XD: Export as images

3. **Specifications**:
   - JSON specs: Store in `assets/specs/`
   - PDF documents: Store in `assets/`

### 에셋 처리 방법
```markdown
## 에셋 제공 방법:

### 옵션 1: 직접 파일 경로
- 파일 저장 위치: .tasks/{유형}_{이름}_{날짜}/assets/
- 문서에서 참조: ![설명](./assets/image.png)

### 옵션 2: 외부 링크
- Figma: 공개 링크 공유 또는 뷰어 접근 권한 제공
- 클라우드 스토리지: 직접 다운로드 링크 제공

### 옵션 3: 인라인 설명
- 간단한 레이아웃에는 ASCII 다이어그램 사용
- 상세한 텍스트 설명 제공
- 구조화된 데이터에는 마크다운 표 사용
````

## Integration with Existing Rules

### Reference Documents

- Follow coding guidelines from: `.cursor/rules/code-writing-guidelines.mdc`
- Apply TypeScript rules from: `.cursor/rules/typescript-react.mdc`
- Maintain project structure per: `.cursor/rules/project-structure.mdc`
- Follow testing strategy from: `.cursor/rules/testing-strategy.mdc`
- **Reference issue resolution workflow from: `.cursor/rules/resolve-issue-guidelines.mdc`**
- **Apply plan execution automation from: `.cursor/rules/plan-execution.mdc`**

### Automated Progress Management

#### 단계별 체크박스 자동 업데이트 규칙

**MUST 실행 시점:**
1. 각 작업(task) 완료 후 즉시
2. 단계(phase) 완료 후 즉시
3. 프로젝트 완료 후 최종

**업데이트 형식:**
```markdown
- [x] 작업 X.Y: 작업 설명 ✓ YYYY-MM-DD 완료
- [x] 단계 X: 단계 설명 ✓ YYYY-MM-DD 완료
```

**자동화 트리거:**
- Task 완료 시: plan-execution 규칙의 커밋 트리거와 연동
- 품질 검증 통과 시: 해당 작업 체크박스 업데이트
- 단계 이동 시: 이전 단계 완료 표시 및 다음 단계 시작

#### 필수 문서화 절차 (단계 6)

**MUST 생성 문서:**
1. `progress_log.md` - 상세 진행 기록
2. `final_status_report.md` - 최종 상태 리포트

**progress_log.md 템플릿:**
```markdown
# Progress Log - {작업명}

## YYYY-MM-DD

### HH:MM - 단계 X 시작
- 작업 X.Y 시작
- 주요 결정사항
- 발생한 문제 및 해결방법

### HH:MM - 작업 X.Y 완료
- 구현 내용 요약
- 품질 검증 결과
- 커밋 해시: abcdef1

## 주요 성과
- 완료된 기능 목록
- 해결한 기술적 과제
- 품질 지표 달성 현황

## 다음 단계 권장사항
- 추가 개선사항
- 주의사항
- 테스트 필요 영역
```

**final_status_report.md 템플릿:**
```markdown
# 최종 상태 리포트 - {작업명}

## 프로젝트 개요
- 목표 달성도: X%
- 완료된 단계: X/Y
- 총 작업 시간: X시간

## 완료된 작업 요약
- 주요 기능 구현 목록
- 해결한 기술적 과제
- 품질 지표 달성 현황

## 품질 검증 결과
- TypeScript 에러: 0개
- 린트 경고: 0개
- 테스트 커버리지: X%
- 빌드 상태: 성공

## 배포 준비도
- 코드 리뷰 상태
- 문서화 완성도
- 테스트 완성도
```

#### 자동 커밋 전략

**문서 업데이트 커밋 순서:**
1. 단계별 작업 커밋 (기존 plan-execution 규칙 따름)
2. 계획 문서 체크박스 업데이트 커밋
3. 진행 기록 및 최종 리포트 커밋

**커밋 메시지 형식:**
```bash
# 계획 문서 업데이트
docs(plan): 단계 X 완료 상태 업데이트 - YYYY-MM-DD

# 진행 기록 생성
docs(progress): 프로젝트 진행 기록 및 최종 상태 리포트 생성

# 최종 완료 커밋
docs(completion): 프로젝트 완료 - 모든 문서화 절차 완료
```

### Workflow Integration

1. Use this rule for new feature development from planning documents
2. Combine with `resolve-issue-guidelines.mdc` for issue-based work
3. Apply `pull-request.mdc` when creating PRs

### Guideline Document Generation Rules

When creating the execution guideline (04_guideline.md), **MUST** reference and integrate patterns from:

#### Core Integration Points:
- **Development Environment Setup**: Follow the Phase 2 setup from `resolve-issue-guidelines.mdc`
- **Quality Assurance Process**: Apply the Phase 4 quality checks and pre-commit checklist
- **Git Workflow**: Use the commit message conventions and branch naming from issue guidelines
- **Technology-Specific Guidelines**: Integrate GraphQL, React, and state management patterns
- **Error Handling**: Apply the documented error recovery procedures

#### Mandatory Sections to Include:
```markdown
## 개발 프로세스 (resolve-issue-guidelines.mdc 기반)

### 환경 설정 확인
- [ ] `nvm use` 실행
- [ ] `yarn api dev` 및 `yarn app dev` 정상 동작 확인
- [ ] `yarn app storybook` 접근 가능 확인

### GraphQL 퍼스트 개발 패턴
1. 스키마 변경 시: `yarn common generate-types`
2. 백엔드 생성 시: `yarn api generate:graphql`
3. MSW 모의 데이터 업데이트
4. Storybook 컴포넌트 개발 우선

### 품질 보증 체크리스트 (Phase 4 기준)
- [ ] 린트 및 포맷팅: `yarn app lint && yarn api lint`
- [ ] 테스트 실행: `yarn app test && yarn api test`
- [ ] 빌드 검증: `yarn app build && yarn api build`
- [ ] 타입 체크: TypeScript 컴파일 에러 없음

### 커밋 전략 (이슈 가이드라인 준수)

#### Frontend Developer Version:
- 논리적 단위별 커밋
- 한국어 커밋 메시지: "feat: 모임 카드 컴포넌트 추가"
- MSW 핸들러 구현 후 즉시 커밋
- 컴포넌트 생성 후 즉시 커밋
- Storybook 스토리 작성 후 즉시 커밋

#### Full-Stack Version:
- 논리적 단위별 커밋
- 한국어 커밋 메시지: "feat: 사용자 인증 기능 추가"
- GraphQL 스키마 변경 후 즉시 커밋
- 컴포넌트 생성 후 즉시 커밋

### 비상 절차

#### Frontend Developer Version:
- 빌드 실패: 이전 작업 커밋으로 되돌리기
- 테스트 실패: MSW 모의 데이터 검증
- GraphQL 타입 오류: `yarn common generate-types` 재실행

#### Full-Stack Version:
- 빌드 실패: 이전 작업 커밋으로 되돌리기
- 테스트 실패: 모의 데이터와 스키마 일치성 확인
- GraphQL 오류: 타입 재생성 및 리졸버 검증
```

## 문서 품질 향상 원칙

### 요구사항 문서 품질 기준

1. **명확성 (Clarity)**
   - 모호한 표현 금지: "적절히", "가능한", "필요시" 등
   - 구체적인 조건과 결과 명시
   - 예: ❌ "시스템은 빠르게 응답해야 한다" → ✅ "시스템은 2초 이내에 응답해야 한다"

2. **검증 가능성 (Testability)**
   - 모든 요구사항은 테스트 가능해야 함
   - 수락 기준은 자동화 테스트로 검증 가능한 형태
   - 예: "WHEN 사용자가 로그인 버튼을 클릭할 때 THEN 시스템은 인증 API를 호출해야 한다"

3. **완전성 (Completeness)**
   - 모든 사용 사례 커버
   - 정상 플로우 + 에러 케이스
   - 엣지 케이스 고려

4. **일관성 (Consistency)**
   - 용어 통일 (예: "사용자" vs "유저")
   - 형식 통일 (EARS 형식 일관되게 적용)
   - 번호 체계 일관성

5. **추적성 (Traceability)**
   - 요구사항 → 설계 → 작업 연결
   - 고유 ID로 추적 가능
   - 변경 이력 관리

### 설계 문서 품질 기준

1. **구현 가능성 (Implementability)**
   - 실제 코드로 구현 가능한 수준의 상세도
   - 코드 예시 포함
   - 파일 경로 명시

2. **아키텍처 결정 근거 (Rationale)**
   - "왜" 이 방식을 선택했는지 설명
   - 대안 고려 및 선택 이유
   - 트레이드오프 명시

3. **요구사항 연결 (Traceability)**
   - 각 설계 결정이 어떤 요구사항을 충족하는지 명시
   - 요구사항 ID 참조

4. **기술적 정확성 (Technical Accuracy)**
   - 사용하는 라이브러리/프레임워크의 실제 API 사용
   - 타입 정의 정확성
   - 베스트 프랙티스 준수

### 작업 목록 품질 기준

1. **실행 가능성 (Actionability)**
   - 각 작업은 명확한 입력과 출력이 있어야 함
   - "무엇을" 만들지 구체적으로 명시
   - 파일 경로 포함

2. **적절한 크기 (Right-Sizing)**
   - 1-4시간 내 완료 가능
   - 너무 크면 분할, 너무 작으면 병합
   - 최대 2단계 계층

3. **의존성 관리 (Dependency Management)**
   - 작업 순서가 의존성을 고려
   - 선행 작업 완료 후 진행 가능한 구조
   - 병렬 가능한 작업 식별

4. **선택적 작업 구분 (Optional Tasks)**
   
   **선택사항(*) 표시 기준**:
   - **단위 테스트**: 선택사항 (통합 테스트로 커버 가능한 경우)
   - **성능 최적화**: 선택사항 (기본 기능 동작 후 개선)
   - **접근성 개선**: 선택사항 (기본 접근성은 필수, 고급 기능은 선택)
   - **추가 에러 처리**: 선택사항 (기본 에러 처리는 필수, 엣지 케이스는 선택)
   - **코드 리팩토링**: 선택사항 (기능 완성 후 개선)
   
   **필수 작업 (선택사항 아님)**:
   - **핵심 기능 구현**: 요구사항을 직접 충족하는 코드
   - **Storybook 스토리**: 컴포넌트 개발 필수 (Frontend Developer)
   - **MSW 핸들러**: API 모킹 필수 (Frontend Developer)
   - **통합 테스트**: 전체 플로우 검증 필수
   - **기본 에러 처리**: 사용자 경험 필수
   - **타입 정의**: TypeScript 프로젝트 필수
   
   **판단 기준**: "이 작업 없이 기능이 동작하는가?"
   - Yes → 선택사항(*)
   - No → 필수

### 문서 간 일관성 유지

1. **용어 통일**
   - 요구사항, 설계, 작업 목록에서 동일한 용어 사용
   - 용어집 작성 권장

2. **ID 체계 일관성**
   - 요구사항: REQ-X.Y
   - 설계: 요구사항 ID 참조
   - 작업: 요구사항 ID 참조

3. **형식 일관성**
   - 마크다운 형식 통일
   - 코드 블록 언어 지정
   - 체크박스 형식 통일

## Claude 사용 프롬프트

### 역할 정의 시:
1. "나는 프론트엔드 개발자야" → Frontend Developer 버전 문서 생성
2. "나는 풀스택 개발자야" → Full-Stack 버전 문서 생성

### 기획 문서 받았을 때:

#### Frontend Developer:
1. "이 기획 문서를 프론트엔드 중심으로 EARS 방법론으로 분석해줘"
2. ".tasks/frontend_{작업명}_{날짜}/ 디렉토리에 프론트엔드 요구사항 문서를 생성해줘"
3. "프론트엔드 중심의 구현 계획을 만들어줘"

#### Full-Stack Developer:
1. "이 기획 문서를 EARS 방법론으로 분석해줘"
2. ".tasks/ 디렉토리에 요구사항 문서를 생성해줘"
3. "요구사항에 기반한 구현 계획을 만들어줘"

### 설계 검토 시:

1. "이 설계를 요구사항과 대조하여 검토해줘"
2. "누락된 요구사항을 찾아줘"
3. "설계 개선사항을 제안해줘"

### 구현 시:

#### Frontend Developer:
1. "X 단계 프론트엔드 계획을 실행해줘"
2. "MSW 모의 핸들러를 먼저 구현해줘"
3. "Storybook에서 컴포넌트를 개발해줘"

#### Full-Stack Developer:
1. "X 단계 계획을 실행해줘"
2. "04_guideline.md의 가이드라인을 따라줘"
3. "완료된 작업을 커밋해줘"

### 단계 완료 시:

1. "단계 X가 완료되었으니 03_plan.md의 체크박스를 업데이트해줘"
2. "각 작업 완료 시점도 함께 기록해줘 (✓ YYYY-MM-DD 완료)"
3. "다음 단계로 진행해줘"

### 프로젝트 완료 시:

1. "모든 단계가 완료되었으니 progress_log.md를 생성해줘"
2. "final_status_report.md도 생성해줘"
3. "계획 문서와 리포트들을 모두 커밋해줘"

## 문서 검증 체크리스트

> 우선순위: 🔴 필수 (반드시 확인) | 🟡 권장 (가능하면 확인) | 🟢 선택 (시간 있으면 확인)

### 요구사항 문서 검증

#### 🔴 필수 검증
- [ ] 모든 요구사항에 고유 ID (REQ-X.Y)가 부여되었는가?
- [ ] 각 요구사항에 EARS 형식 수락 기준이 있는가?
- [ ] 요구사항이 검증 가능한가? (테스트 가능한가?)
- [ ] 모호한 표현이 없는가? ("적절히", "가능한", "빠르게" 등)

#### 🟡 권장 검증
- [ ] 각 요구사항에 사용자 스토리가 있는가?
- [ ] 우선순위 (High/Medium/Low)가 명시되었는가?
- [ ] 비기능 요구사항이 구체적인 지표로 명시되었는가?
- [ ] 주요 의존성이 식별되었는가?

#### 🟢 선택 검증
- [ ] 용어가 일관되게 사용되는가?
- [ ] 요구사항 간 중복이 없는가?
- [ ] 위험 요소와 완화 방안이 있는가?

### 설계 문서 검증

#### 🔴 필수 검증
- [ ] 모든 High 우선순위 요구사항이 설계에 반영되었는가?
- [ ] 설계가 기술적으로 구현 가능한가?
- [ ] 파일 경로가 프로젝트 구조와 일치하는가?
- [ ] 데이터 흐름이 명확한가?

#### 🟡 권장 검증
- [ ] 각 설계 결정이 요구사항 ID (REQ-X.Y)를 참조하는가?
- [ ] 코드 예시가 실제 동작 가능한가?
- [ ] 에러 처리 전략이 있는가?
- [ ] 사용하는 라이브러리/API가 정확한가?

#### 🟢 선택 검증
- [ ] 아키텍처 결정의 근거가 설명되었는가?
- [ ] 대안이 고려되었는가?
- [ ] 성능 영향이 분석되었는가?
- [ ] 테스트 전략이 정의되었는가?

### 작업 목록 검증

#### 🔴 필수 검증
- [ ] 모든 작업이 코딩 활동인가? (비코딩 작업 제외)
- [ ] 각 작업에 5개 필드가 있는가? (파일, 내용, 방법, 완료, Requirements)
- [ ] 각 작업이 요구사항 ID (REQ-X.Y)를 참조하는가?
- [ ] 모든 High 우선순위 요구사항이 작업으로 커버되는가?

#### 🟡 권장 검증
- [ ] 각 작업이 1-4시간 내 완료 가능한가?
- [ ] 작업 순서가 의존성을 고려하는가?
- [ ] 선택적 작업이 적절히 표시되었는가? (*)
- [ ] 완료 기준이 검증 가능한가?

#### 🟢 선택 검증
- [ ] 계층이 2단계를 초과하지 않는가?
- [ ] 병렬 가능한 작업이 식별되었는가?
- [ ] 설정 및 준비 작업이 포함되었는가?
- [ ] 품질 검증 작업이 포함되었는가?

### 문서 간 일관성 검증

#### 🔴 필수 검증
- [ ] 요구사항 ID (REQ-X.Y)가 설계와 작업에서 일관되게 참조되는가?
- [ ] 모든 High 우선순위 요구사항이 설계와 작업에 반영되었는가?

#### 🟡 권장 검증
- [ ] 요구사항, 설계, 작업에서 동일한 용어를 사용하는가?
- [ ] 마크다운 형식이 통일되었는가?
- [ ] 코드 블록에 언어가 지정되었는가? (```typescript, ```graphql 등)

#### 🟢 선택 검증
- [ ] 전문 용어에 대한 설명이 있는가?
- [ ] 참고 자료가 링크되었는가?
- [ ] 버전 정보가 명시되었는가?

---

## 빠른 검증 가이드

**시간이 부족할 때 최소한 확인할 것** (5분 체크리스트):

### 요구사항 문서
1. [ ] 모든 요구사항에 REQ-X.Y ID가 있는가?
2. [ ] EARS 형식 (WHEN/IF/WHILE THEN)을 사용했는가?
3. [ ] 모호한 표현 ("적절히", "빠르게" 등)이 없는가?

### 설계 문서
1. [ ] 파일 경로가 프로젝트 구조와 일치하는가?
2. [ ] 데이터 흐름이 명확한가?
3. [ ] 요구사항 ID를 참조하는가?

### 작업 목록
1. [ ] 모든 작업에 5개 필드 (파일, 내용, 방법, 완료, Requirements)가 있는가?
2. [ ] 비코딩 작업 (배포, 회의 등)이 없는가?
3. [ ] 요구사항 ID를 참조하는가?

---

> Last Updated: 2024
> Universal Rule: Requirement-Driven Development (Project-Agnostic)
